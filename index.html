<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Text Processor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --bg-gradient-from: #f5f7fa;
      --bg-gradient-middle: #c8d6e5;
      --bg-gradient-to: #92a8ca;
      --text-primary: #1f2937;
      --text-secondary: #4b5563;
      --card-bg: #ffffff;
      --card-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --input-border: #d1d5db;
      --input-bg: #ffffff;
      --input-focus: #6366f1;
      --button-primary: #6366f1;
      --button-primary-hover: #4f46e5;
      --button-text: #ffffff;
      --stats-bg-1: #eef2ff;
      --stats-text-1: #6366f1;
      --stats-bg-2: #ecfdf5;
      --stats-text-2: #10b981;
      --stats-bg-3: #fef2f2;
      --stats-text-3: #ef4444;
      --stats-bg-4: #f5f3ff;
      --stats-text-4: #8b5cf6;
      --stats-bg-5: #fffbee;
      --stats-text-5: #664d03;
    }

    .dark {
      --bg-gradient-from: #1f2937;
      --bg-gradient-middle: #374151;
      --bg-gradient-to: #111827;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --card-bg: #374151;
      --card-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
      --input-border: #4b5563;
      --input-bg: #1f2937;
      --input-focus: #818cf8;
      --button-primary: #6366f1;
      --button-primary-hover: #4f46e5;
      --button-text: #ffffff;
      --stats-bg-1: #312e81;
      --stats-text-1: #a5b4fc;
      --stats-bg-2: #065f46;
      --stats-text-2: #6ee7b7;
      --stats-bg-3: #7f1d1d;
      --stats-text-3: #fca5a5;
      --stats-bg-4: #4c1d95;
      --stats-text-4: #c4b5fd;
      --stats-bg-5: #664d03;
      --stats-text-5: #fff5d6;
    }

    .gradient-bg {
      background: linear-gradient(135deg, var(--bg-gradient-from) 0%, var(--bg-gradient-middle) 50%, var(--bg-gradient-to) 100%);
    }

    .text-area {
      min-height: 200px;
      transition: all 0.3s ease;
      background-color: var(--input-bg);
      color: var(--text-primary);
      border-color: var(--input-border);
    }

    .text-area:focus {
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
      border-color: var(--input-focus);
    }

    .badge {
      transition: all 0.2s ease;
    }

    .badge:hover {
      transform: translateY(-2px);
    }
    
    /* Clickable stats cards */
    .stats-card {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .stats-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: var(--card-bg);
      color: var(--text-primary);
      border-radius: 0.5rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    }

    .slide-in {
      animation: slideIn 0.3s ease-out forwards;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Toggle Switch Styles */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--button-primary);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
  </style>
</head>

<body class="gradient-bg min-h-screen p-4 md:p-8 transition-colors duration-300">
  <div class="max-w-4xl mx-auto">
    <header class="text-center mb-10">
      <h1 class="text-4xl font-bold text-[var(--text-primary)] mb-2">Text Processor</h1>
      <p class="text-[var(--text-secondary)]">Clean and modify your text with ease</p>
      <div class="flex items-center justify-center mt-4">
        <span class="mr-2 text-[var(--text-secondary)]"><i class="fas fa-sun"></i></span>
        <label class="toggle-switch">
          <input type="checkbox" id="dark-mode-toggle">
          <span class="toggle-slider"></span>
        </label>
        <span class="ml-2 text-[var(--text-secondary)]"><i class="fas fa-moon"></i></span>
      </div>
    </header>

    <div class="bg-[var(--card-bg)] rounded-xl shadow-lg overflow-hidden mb-8 transition-colors duration-300">
      <div class="p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold text-[var(--text-primary)]">Input Context</h2>
          <button id="clear-all" class="text-sm text-red-500 hover:text-red-700 flex items-center">
                        <i class="fas fa-trash-alt mr-1"></i> Clear All
                    </button>
        </div>
        <textarea id="context-input" class="text-area w-full p-4 border rounded-lg focus:outline-none" placeholder="Paste your text here..."></textarea>
      </div>
    </div>

    <div class="bg-[var(--card-bg)] rounded-xl shadow-lg overflow-hidden mb-8 transition-colors duration-300">
      <div class="p-6">
        <h2 class="text-xl font-semibold text-[var(--text-primary)] mb-4">Words and Symbols to Remove</h2>
        <div class="flex flex-wrap gap-2 mb-4" id="words-container">
          <!-- Words will appear here -->
        </div>
        <div class="flex">
          <input type="text" id="word-input" class="flex-grow p-3 border rounded-l-lg focus:outline-none focus:border-[var(--input-focus)] bg-[var(--input-bg)] text-[var(--text-primary)] border-[var(--input-border)]" placeholder="Enter word to remove...">
          <button id="add-word" class="bg-[var(--button-primary)] hover:bg-[var(--button-primary-hover)] text-[var(--button-text)] px-4 rounded-r-lg transition-colors">
                        <i class="fas fa-plus"></i> Add
                    </button>
        </div>
        <p class="text-sm text-[var(--text-secondary)] mt-2">Separate multiple words with commas</p>
      </div>
    </div>

    <div class="bg-[var(--card-bg)] rounded-xl shadow-lg overflow-hidden mb-8 transition-colors duration-300">
      <div class="p-6">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold text-[var(--text-primary)]">Processed Text</h2>
          <button id="copy-result" class="text-sm text-[var(--button-primary)] hover:text-[var(--button-primary-hover)] flex items-center">
                        <i class="fas fa-copy mr-1"></i> Copy
                    </button>
        </div>
        <div class="relative">
          <div id="processed-output" class="text-area w-full p-4 border rounded-lg min-h-[200px] max-h-[300px] overflow-y-auto transition-all duration-300">
            <p class="text-[var(--text-secondary)] italic">Your processed text will appear here...</p>
          </div>
          <button id="expand-btn" class="absolute bottom-3 right-3 bg-[var(--button-primary)] text-[var(--button-text)] p-1 rounded-md opacity-70 hover:opacity-100 transition-opacity hidden">
            <i class="fas fa-expand-alt"></i>
          </button>
        </div>
        <div class="flex justify-end mt-4">
          <button id="process-btn" class="bg-[var(--button-primary)] hover:bg-[var(--button-primary-hover)] text-[var(--button-text)] px-6 py-3 rounded-lg font-medium transition-colors flex items-center">
                        <i class="fas fa-magic mr-2"></i> Process Text
                    </button>
        </div>
      </div>
    </div>

    <div class="bg-[var(--card-bg)] rounded-xl shadow-lg overflow-hidden transition-colors duration-300">
      <div class="p-6">
        <h2 class="text-xl font-semibold text-[var(--text-primary)] mb-4">Statistics</h2>
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
          <div class="bg-[var(--stats-bg-1)] p-4 rounded-lg text-center transition-colors duration-300 stats-card">
            <p class="text-sm text-[var(--stats-text-1)] font-medium">Original Words</p>
            <p id="original-count" class="text-2xl font-bold text-[var(--stats-text-1)]">0</p>
          </div>
          <div class="bg-[var(--stats-bg-2)] p-4 rounded-lg text-center transition-colors duration-300 stats-card">
            <p class="text-sm text-[var(--stats-text-2)] font-medium">Processed Words</p>
            <p id="processed-count" class="text-2xl font-bold text-[var(--stats-text-2)]">0</p>
          </div>
          <div id="removed-words-card" class="bg-[var(--stats-bg-3)] p-4 rounded-lg text-center transition-colors duration-300 stats-card">
            <p class="text-sm text-[var(--stats-text-3)] font-medium">Words Removed <i class="fas fa-eye ml-1 text-xs"></i></p>
            <p id="removed-count" class="text-2xl font-bold text-[var(--stats-text-3)]">0</p>
          </div>
          <div id="asterisk-words-card" class="bg-[var(--stats-bg-4)] p-4 rounded-lg text-center transition-colors duration-300 stats-card">
            <p class="text-sm text-[var(--stats-text-4)] font-medium">Asterisk Words <i class="fas fa-eye ml-1 text-xs"></i></p>
            <p id="asterisk-count" class="text-2xl font-bold text-[var(--stats-text-4)]">0</p>
          </div>
        </div>
        <div class="grid grid-cols-1 gap-4">
          <div id="symbols-removed-card" class="bg-[var(--stats-bg-5)] p-4 rounded-lg text-center transition-colors duration-300 stats-card">
            <p class="text-sm text-[var(--stats-text-5)] font-medium">Symbols Removed <i class="fas fa-eye ml-1 text-xs"></i></p>
            <p id="symbols-count" class="text-2xl font-bold text-[var(--stats-text-5)]">0</p>
          </div>
        </div>
        
        <!-- Modal for displaying removed content -->
        <div id="content-modal" class="modal">
          <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
              <h3 id="modal-title" class="text-xl font-semibold text-[var(--text-primary)]"></h3>
              <button id="close-modal" class="text-[var(--text-secondary)] hover:text-[var(--text-primary)]">
                <i class="fas fa-times"></i>
              </button>
            </div>
            <div id="modal-content" class="max-h-[400px] overflow-y-auto"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
            // Dark mode toggle functionality
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const htmlElement = document.documentElement;
            
            // Check for saved theme preference or use system preference
            const savedTheme = localStorage.getItem('theme');
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            // Set initial theme based on saved preference or system preference
            if (savedTheme === 'dark' || (!savedTheme && prefersDarkMode)) {
                htmlElement.classList.add('dark');
                darkModeToggle.checked = true;
            }
            
            // Toggle dark mode when switch is clicked
            darkModeToggle.addEventListener('change', function() {
                if (this.checked) {
                    htmlElement.classList.add('dark');
                    localStorage.setItem('theme', 'dark');
                } else {
                    htmlElement.classList.remove('dark');
                    localStorage.setItem('theme', 'light');
                }
            });
            // DOM elements
            const contextInput = document.getElementById('context-input');
            const wordInput = document.getElementById('word-input');
            const addWordBtn = document.getElementById('add-word');
            const processBtn = document.getElementById('process-btn');
            const processedOutput = document.getElementById('processed-output');
            const wordsContainer = document.getElementById('words-container');
            const clearAllBtn = document.getElementById('clear-all');
            const copyResultBtn = document.getElementById('copy-result');
            
            // Stats elements
            const originalCount = document.getElementById('original-count');
            const processedCount = document.getElementById('processed-count');
            const removedCount = document.getElementById('removed-count');
            const asteriskCount = document.getElementById('asterisk-count');
            const symbolsCount = document.getElementById('symbols-count');
            
            // Words to remove array
            let wordsToRemove = [];
            
            // Objects to track removed content and their counts
            let removedWordsMap = {};
            let asteriskWordsMap = {};
            let symbolsRemovedMap = {};
            
            // Modified addWords function to handle comma-separated input and normalize text
            function addWords() {
                const input = wordInput.value.trim();
                if (!input) return;
                
                // Split by commas and trim each word
                const newWords = input.split(',').map(word => word.trim()).filter(word => word);
                
                // Add to wordsToRemove if not already there
                newWords.forEach(word => {
                    // Normalize the word by removing any formatting
                    const normalizedWord = normalizeText(word).toLowerCase();
                    if (!wordsToRemove.includes(normalizedWord)) {
                        wordsToRemove.push(normalizedWord);
                        createWordBadge(word);
                    }
                });
                
                wordInput.value = '';
                wordInput.focus();
            }
            
            // Function to normalize text by removing formatting and handling Unicode characters
            function normalizeText(text) {
                // Create a temporary div element to strip formatting
                const tempDiv = document.createElement('div');
                tempDiv.textContent = text;
                
                // Get the text content
                let normalizedText = tempDiv.textContent;
                
                // Custom mapping for special Unicode characters, particularly small capital letters
                // This handles cases like ʟɪɢʜᴛɴᴏᴠᴇʟᴡᴏʀʟᴅ.ᴄᴏᴍ
                const unicodeMap = {
                    // Small capital letters to regular letters
                    'ᴀ': 'a', 'ʙ': 'b', 'ᴄ': 'c', 'ᴅ': 'd', 'ᴇ': 'e', 'ꜰ': 'f', 'ɢ': 'g', 'ʜ': 'h', 'ɪ': 'i', 
                    'ᴊ': 'j', 'ᴋ': 'k', 'ʟ': 'l', 'ᴍ': 'm', 'ɴ': 'n', 'ᴏ': 'o', 'ᴘ': 'p', 'ǫ': 'q', 'ʀ': 'r', 
                    'ꜱ': 's', 'ᴛ': 't', 'ᴜ': 'u', 'ᴠ': 'v', 'ᴡ': 'w', 'x': 'x', 'ʏ': 'y', 'ᴢ': 'z',
                    // Other common special characters
                    'ᴅ': 'd', 'ᴇ': 'e', 'ɪ': 'i', 'ᴍ': 'm', 'ɴ': 'n', 'ᴏ': 'o', 'ᴛ': 't', 'ʟ': 'l',
                    'ɢ': 'g', 'ʜ': 'h', 'ᴡ': 'w', 'ʀ': 'r', 'ᴄ': 'c'
                };
                
                // Apply custom character mapping
                for (const [unicode, ascii] of Object.entries(unicodeMap)) {
                    normalizedText = normalizedText.replace(new RegExp(unicode, 'g'), ascii);
                }
                
                // Apply Unicode normalization (NFKD: Compatibility Decomposition)
                // This converts special Unicode characters to their standard equivalents
                normalizedText = normalizedText.normalize('NFKD');
                
                // Replace any remaining non-ASCII characters with their closest ASCII equivalents
                normalizedText = normalizedText.replace(/[\u0300-\u036f]/g, ''); // Remove combining diacritical marks
                
                return normalizedText;
            }
            
            // Add event listener for the 'Add' button
            addWordBtn.addEventListener('click', addWords);
            
            // Modified processText function for asterisk reconstruction and word removal
            function processText() {
                const text = contextInput.value;
                if (!text.trim()) {
                    processedOutput.innerHTML = '<p class="text-red-400 italic">Please enter some text to process.</p>';
                    return;
                }
                
                // Reset tracking maps before each processing
                removedWordsMap = {};
                asteriskWordsMap = {};
                symbolsRemovedMap = {};
                
                // Split text into paragraphs and process each one separately
                const paragraphs = text.split('\n');
                let processedParagraphs = [];
                let originalWordCount = 0;
                let asteriskWordsFound = 0;
                let symbolsRemoved = 0;
                
                paragraphs.forEach(paragraph => {
                    if (!paragraph.trim()) {
                        processedParagraphs.push('');
                        return;
                    }
                    
                    // Count original words for this paragraph
                    const originalWords = paragraph.split(/\s+/).filter(word => word);
                    originalWordCount += originalWords.length;
                    
                    // Process the paragraph
                    let processedText = paragraph;
                    
                    // Handle asterisk words - Replace asterisks with appropriate letters in any position
                    processedText = processedText.replace(/\b\w*\*\w*\b/g, function(match) {
                        // Count each word with asterisks
                        asteriskWordsFound++;
                        // Add to asterisk words map or increment count if already there
                        if (asteriskWordsMap[match]) {
                            asteriskWordsMap[match]++;
                        } else {
                            asteriskWordsMap[match] = 1;
                        }
                        // Replace asterisks with their original letters
                        const replacements = {
                            'f*cking': 'fucking',
                            'f*ck': 'fuck',
                            'f*cked': 'fucked',
                            'f*cks': 'fucks',
                            'motherf*cking': 'motherfucking',
                            'motherf*cked': 'motherfucked',
                            'motherf*cker':'motherfucker',
                            'motherf*ckers': 'motherfuckers',
                            'bullsh*t': 'bullshit',
                            'bullsh*ts': 'bullshits',
                            'bullsh*ting': 'bullsh*ting',
                            'b*tch': 'bitch',
                            'b*tches': 'bitches',
                            'b*tching': 'bitching',
                            's*ck': 'suck',
                            's*cks':'sucks',
                            's*cking':'sucking',
                            's*cked':'sucked',
                            'sh*t': 'shit',
                            'sh*ts':'shits',
                            'sh*tty':'shitty',
                            'd*ck': 'dick',
                            'd*cks': 'dicks',
                            'a**hole': 'asshole',
                            'a**holes': 'assholes',
                            'b*stard': 'bastard',
                            'b*stards': 'bastards',
                            'b*llock': 'bollock',
                            'b*llocks': 'bollocks',
                            'p*ssy': 'pussy',
                            'p*ssies': 'pussies',
                            'p*ssying': 'pussying',
                            'p*ssed': 'pussied',
                            'p*ss': 'piss',
                            'p*sses': 'pisses',
                            'p*ssing': 'pissing',
                            'p*ssed': 'pissed',
                            'c*nt': 'cunt',
                            'c*nts': 'cunts',
                            'c*nter': 'cunter',
                            'c*nters': 'cunters',


                    };
                    return replacements[match.toLowerCase()] || match.replace(/\*/g, '');
                });
                
                // 2. Remove specified words and symbols (case insensitive)
                    if (wordsToRemove.length > 0) {
                        // Process each word to remove
                        for (const wordToRemove of wordsToRemove) {
                            // Normalize both the text and the word to remove
                            const normalizedWordToRemove = normalizeText(wordToRemove).toLowerCase();
                            
                            // Create a new normalized version of the current processed text for each word
                            let normalizedProcessedText = normalizeText(processedText).toLowerCase();
                            
                            // Check if it's a word (contains only alphanumeric characters)
                            if (/^\w+$/.test(normalizedWordToRemove)) {
                                // For words, use word boundaries
                                const wordRegex = new RegExp(`\\b${normalizedWordToRemove.replace(/[\\^$.*+?()[{}|\\]/g, '\\$&')}\\b`, 'gi');
                                
                                // Find all occurrences in the normalized text
                                let match;
                                let positions = [];
                                while ((match = wordRegex.exec(normalizedProcessedText)) !== null) {
                                    positions.push({ start: match.index, length: match[0].length });
                                }
                                
                                // Remove words from the original text (starting from the end to maintain indices)
                                for (let i = positions.length - 1; i >= 0; i--) {
                                    const { start, length } = positions[i];
                                    // Get the actual word being removed from the original text
                                    const removedWord = processedText.substring(start, start + length);
                                    // Add to removed words map or increment count if already there
                                    if (removedWordsMap[removedWord]) {
                                        removedWordsMap[removedWord]++;
                                    } else {
                                        removedWordsMap[removedWord] = 1;
                                    }
                                    processedText = processedText.substring(0, start) + processedText.substring(start + length);
                                }
                            } else {
                                // For symbols and special characters, don't use word boundaries
                                const symbolRegex = new RegExp(normalizedWordToRemove.replace(/[\\^$.*+?()[{}|\\]/g, '\\$&'), 'gi');
                                
                                // Find all occurrences in the normalized text
                                let match;
                                let positions = [];
                                while ((match = symbolRegex.exec(normalizedProcessedText)) !== null) {
                                    positions.push({ start: match.index, length: match[0].length });
                                }
                                
                                // Remove symbols from the original text (starting from the end to maintain indices)
                                for (let i = positions.length - 1; i >= 0; i--) {
                                    const { start, length } = positions[i];
                                    // Get the actual symbol being removed from the original text
                                    const removedSymbol = processedText.substring(start, start + length);
                                    // Add to symbols removed map or increment count if already there
                                    if (symbolsRemovedMap[removedSymbol]) {
                                        symbolsRemovedMap[removedSymbol]++;
                                    } else {
                                        symbolsRemovedMap[removedSymbol] = 1;
                                    }
                                    processedText = processedText.substring(0, start) + processedText.substring(start + length);
                                    // Count each symbol removed
                                    symbolsRemoved++;
                                }
                            }
                        }
                    }
                    
                    // 3. Clean up extra spaces within paragraph
                    processedText = processedText.replace(/\s+/g, ' ').trim();
                    
                    processedParagraphs.push(processedText);
                });
                
                // Count processed words
                let processedWordCount = 0;
                processedParagraphs.forEach(p => {
                    if (p.trim()) {
                        processedWordCount += p.split(/\s+/).filter(word => word).length;
                    }
                });
                
                // Update stats
                originalCount.textContent = originalWordCount;
                processedCount.textContent = processedWordCount;
                removedCount.textContent = originalWordCount - processedWordCount;
                asteriskCount.textContent = asteriskWordsFound;
                symbolsCount.textContent = symbolsRemoved;
                
                // Display result with preserved paragraphs
                const finalText = processedParagraphs.join('\n');
                if (finalText.trim()) {
                    // Escape HTML special characters to prevent them from being interpreted as HTML tags
                    const escapedText = finalText
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                    processedOutput.innerHTML = escapedText.replace(/\n/g, '<br>');
                } else {
                    processedOutput.innerHTML = '<p class="text-gray-400 italic">All content was removed.</p>';
                }
                
                // Update expand button visibility
                updateExpandButtonVisibility();
            }
            
            // Create a badge for a word
            function createWordBadge(word) {
                const badge = document.createElement('div');
                badge.className = 'badge bg-[var(--input-bg)] text-[var(--text-primary)] border border-[var(--input-border)] px-3 py-1 rounded-full flex items-center slide-in transition-colors duration-300';
                badge.innerHTML = `
                    ${word}
                    <button class="ml-2 text-[var(--text-secondary)] hover:text-red-500" data-word="${word.toLowerCase()}">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                `;
                
                wordsContainer.appendChild(badge);
                
                // Add event to remove button
                badge.querySelector('button').addEventListener('click', function() {
                    const wordToRemove = this.getAttribute('data-word');
                    wordsToRemove = wordsToRemove.filter(w => w !== wordToRemove);
                    badge.remove();
                });
            }
            
            // Clear all button
            clearAllBtn.addEventListener('click', function() {
                contextInput.value = '';
                wordsToRemove = [];
                wordsContainer.innerHTML = '';
                processedOutput.innerHTML = '<p class="text-gray-400 italic">Your processed text will appear here...</p>';
                updateStats(0, 0, 0, 0);
                updateExpandButtonVisibility();
            });
            
            // Copy result button
            copyResultBtn.addEventListener('click', function() {
                const text = processedOutput.innerText;
                if (!text || text.includes('Your processed text')) return;
                
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-check mr-1"></i> Copied!';
                    setTimeout(() => {
                        this.innerHTML = originalText;
                    }, 2000);
                });
            });
            
            // Process text button
            processBtn.addEventListener('click', processText);
            
            // Expand/collapse functionality for processed text
            const expandBtn = document.getElementById('expand-btn');
            let isExpanded = false;
            
            // Show expand button only when there's content
            function updateExpandButtonVisibility() {
                const content = processedOutput.innerText;
                if (content && !content.includes('Your processed text') && !content.includes('Please enter some text')) {
                    expandBtn.classList.remove('hidden');
                } else {
                    expandBtn.classList.add('hidden');
                }
            }
            
            // Toggle expand/collapse
            expandBtn.addEventListener('click', function() {
                isExpanded = !isExpanded;
                if (isExpanded) {
                    processedOutput.classList.remove('max-h-[300px]');
                    processedOutput.classList.add('max-h-[800px]');
                    this.innerHTML = '<i class="fas fa-compress-alt"></i>';
                } else {
                    processedOutput.classList.add('max-h-[300px]');
                    processedOutput.classList.remove('max-h-[800px]');
                    this.innerHTML = '<i class="fas fa-expand-alt"></i>';
                }
            });
            
            // Initialize stats
            function updateStats(original, processed, removed, asterisk, symbols = 0) {
                originalCount.textContent = original;
                processedCount.textContent = processed;
                removedCount.textContent = removed;
                asteriskCount.textContent = asterisk;
                symbolsCount.textContent = symbols;
                
                // Reset tracking maps when stats are reset
                removedWordsMap = {};
                asteriskWordsMap = {};
                symbolsRemovedMap = {};
            }
            
            // Modal functionality
            const contentModal = document.getElementById('content-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalContent = document.getElementById('modal-content');
            const closeModal = document.getElementById('close-modal');
            
            // Close modal when clicking the close button
            closeModal.addEventListener('click', function() {
                contentModal.style.display = 'none';
            });
            
            // Close modal when clicking outside the modal content
            contentModal.addEventListener('click', function(event) {
                if (event.target === contentModal) {
                    contentModal.style.display = 'none';
                }
            });
            
            // Function to display items in the modal with their counts
            function showItemsInModal(title, itemsMap) {
                modalTitle.textContent = title;
                
                if (Object.keys(itemsMap).length === 0) {
                    modalContent.innerHTML = '<p class="text-[var(--text-secondary)] italic">No items to display.</p>';
                } else {
                    let content = '<ul class="list-disc pl-5 space-y-1">';
                    for (const [item, count] of Object.entries(itemsMap)) {
                        content += `<li class="text-[var(--text-primary)]">${item} <span class="text-[var(--text-secondary)] font-medium">(${count})</span></li>`;
                    }
                    content += '</ul>';
                    modalContent.innerHTML = content;
                }
                
                contentModal.style.display = 'flex';
            }
            
            // Add click event listeners to the statistic cards
            document.getElementById('removed-words-card').addEventListener('click', function() {
                showItemsInModal('Removed Words', removedWordsMap);
            });
            
            document.getElementById('asterisk-words-card').addEventListener('click', function() {
                showItemsInModal('Asterisk Words', asteriskWordsMap);
            });
            
            document.getElementById('symbols-removed-card').addEventListener('click', function() {
                showItemsInModal('Symbols Removed', symbolsRemovedMap);
            });
        });
  </script>
</body>

</html>
